---
title: 'MAST: A flexible statistical framework for assessing transcriptional changes
  and characterizing heterogeneity in single-cell RNA-seq data. MAIT Analysis.'
author: Greg Finak, Andrew McDavid, Masanao Yajima, Jingyuan Deng, Vivian Gersuk, Alex Shalek, Chloe K. Schlicter, Hannah W. Miller, M. Juliana McElrath, Martin  Prlic, Peter Linsley, Raphael Gottardo
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MAIT Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---
# Stimulated vs. Non-stimulated MAIT Cells


We will learn how to use the package [MAST](http://genomebiology.biomedcentral.com/articles/10.1186/s13059-015-0844-5) to analyze single cell gene expression experiments.

Starting from a matrix of counts of transcripts (cells by transcripts), we will discuss the preliminary steps of quality control, filtering, and exploratory data analysis.  Once we are satisfied that we have high-quality expression, we will consider tests for differential expression and ways to visualize results.
It is often helpful to synthesize from gene-level into module-level statements.  Therefore, we will learn how to use MAST to test for gene set enrichment.

An example data set of Mucosal Associated Invariant T cells (MAITs) that have been cytokine stimulated will be provided.  Participants are also encouraged to bring their own data.

Prerequisites for this class will include basic R syntax, plotting and manipulation of data using `data.table` and `ggplot2`.  Background with linear models may be useful as well.


```{r eval=FALSE}
library(devtools)
install_github('RGLab/MAST@summarizedExpt')
library(BiocInstaller)
useDevel()
biocLite('SummarizedExperiment')
biocValid()
```
If you are running this at BioC, you should not need to run this chunk.
Otherwise you will need to install the summarizedExpt branch and the devel (3.4) branch of Bioconductor.


```{r libraries,echo=FALSE, error=FALSE,echo=FALSE,results='hide',warnin=FALSE}
suppressPackageStartupMessages({
    library("ggplot2")
    library(GGally)
    library("GSEABase")
    library("limma")
    library("reshape2")
    library(RColorBrewer)
    library("data.table")
    library("knitr")
#library(psych)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(org.Hs.eg.db)
#library(flowClust)
#library(COMPASS)
    ##library(scales)
    library(stringr)
    library(class)
    library(NMF)
    library(rsvd)
options(mc.cores = detectCores() - 1) #or set smaller if you find yourself running out of memory
options(mc.cores = 1) #or set smaller if you find yourself running out of memory
})
LARGE_MEMORY_CORES <- 1 #for large memory operations
knitr::opts_chunk$set(echo = FALSE,eval = TRUE,message = FALSE,error = FALSE,warning = FALSE,cache = TRUE,fig.width=10,fig.height=8)
plotheme <-
theme(
plot.background = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line =
element_line(colour = "black")
)

```

# Loading and transforming data
```{r MASToptions}
percent_expressed <- 0.2
FCTHRESHOLD <- log2(1.5)
```
First, let's set some constants that we can use throughout this analysis.



```{r data,results='hide'}
data(maits)
dim(maits$expressionmat)
head(maits$cdat)
head(maits$fdat)
```
Next, let's load the data, which consists of a matrix of log2 + 1 transcripts per million (TPM), as output by RSEM.
Internally, we use the packages RNASeqPipelineR and preprocessData to facilitate aligning and quantitating the raw reads.
This is an experiment on Mucosal Associated Invariant T-cells from a single healthy donor.
A number of cells were subjected to reverse transcription and library prep immediately, while others were first stimulated for 24 hours with a cytokine cocktail.


```{r createSca}
scaRaw <- FromMatrix(t(maits$expressionmat), maits$cdat, maits$fdat)
```
There are `r ncol(scaRaw)` single cells measured over `r nrow(scaRaw)` genes.
We derive from the `SummarizedExperiment` class, which makes it easy for feature (row) and cell (column) meta data to come along for the ride.


## EDA
Let's explore these data with a heatmap and some PCA.
```{r heatmap}
aheatmap(assay(scaRaw[1:1000,]), labRow='', annCol=as.data.frame(colData(scaRaw)[,c('condition', 'ourfilter')]), distfun='spearman')
```

```{r pca}
set.seed(123)
plotPCA <- function(sca_obj){
    projection <- rpca(t(assay(sca_obj)), retx=TRUE, k=4)$x
    pca <- data.table(projection,  as.data.frame(colData(sca_obj)))
    print(ggpairs(pca, columns=c('PC1', 'PC2', 'PC3', 'libSize', 'PercentToHuman', 'nGeneOn', 'exonRate'),
            mapping=aes(color=condition), upper=list(continuous='blank')))
    invisible(pca)
}

plotPCA(scaRaw)

filterCrit <- with(colData(scaRaw), pastFastqc=="PASS"& exonRate >0.3 & PercentToHuman>0.6 & nGeneOn> 4000)
```
From the PCA and  heatmap we can tell that we've got some data quality issues with low-diversity libraries, and libraries where we capture a lot of non mRNA.
We'll set a filtering threshold using the [Potter Stewart](https://en.wikipedia.org/wiki/I_know_it_when_I_see_it) method, though Shalek et al and others have come up with more principled ways, such as training SVM on the expression data and quality metrics to predict failed libraries.  Though this still presupposes a set of labeled "failures" and "successes".


## Filtering
```{r filter_outlying_cell,results='hide'}
sca <- subset(scaRaw,filterCrit)
eid <- select(TxDb.Hsapiens.UCSC.hg19.knownGene,keys = mcols(sca)$entrez,keytype ="GENEID",columns = c("GENEID","TXNAME"))
ueid <- unique(na.omit(eid)$GENEID)
sca <- sca[mcols(sca)$entrez %in% ueid,]
## Remove invariant genes
sca <- sca[freq(sca)>0,]
```
We'll now consider only cells that pass the filter.  `subset(scaRaw, filterCrit)` is just syntactic sugar for subsetting by columns, but who doesn't like a little sugar?
We'll also limit ourselves to transcripts that have a an entrez gene id to facilitate interpretation.

### PCA on filtered cells
```{r pcaFilter}
plotPCA(sca)
```
PC1 now primarily captures stimulation effects.
We still observe that PC2 correlates with the exonRate and ngeneson, but the data are more smoothly distributed.

## Adaptive thresholding
```{r distribution, fig.width=8, fig.height=8}
scaSample <- sca[sample(nrow(sca), 20),]
flat <- as(scaSample, 'data.table')
ggplot(flat, aes(x=value))+geom_density() +facet_wrap(~symbolid, scale='free_y')

```
Single cell gene expression data are known to be zero-inflated and bimodal, which is feature we observe here as well.
Here we've taken subsample of size 20, then flattened it into a `data.table` to make it easy to plot with `ggplot2`.


```{r threshold, results='hide'}
thres <- thresholdSCRNACountMatrix(assay(sca), nbins = 20, min_per_bin = 30)
par(mfrow=c(5,4))
plot(thres)

```
We suspect that the left-most mode corresponds to non-specific hybridization of mRNA or genomic DNA.
Here we apply an adaptive scheme to threshold values below a cut-off that depends on the intensity of the signal cluster from the gene (determined from the median expression value).
When we plot the threshold vs genes binned by median expression value, we can see this evolution of thresholding value.


```{r assignThresh}
assays(sca) <- list(thresh=thres$counts_threshold, tpm=assay(sca))
expressed_genes <- freq(sca) > percent_expressed
sca <- sca[expressed_genes,]
```
We'll limit ourselves to genes that are found in at least `r percent_expressed` fraction of the sample (since we won't have any power to conclude much about less frequent transcripts).

# Differential Expression using a Hurdle model
```{r zlm}
options(mc.cores=LARGE_MEMORY_CORES)
# ZLM (ridge regression for continuous, get standardized deviance residuals)
cond<-factor(colData(sca)$condition)
cond<-relevel(cond,"Unstim")
colData(sca)$condition<-cond
zlmCond <- zlm.SingleCellAssay(~condition + cngeneson, sca)
## The following are equivalent
## lrt <- lrTest(zlm, "condition")
## lrt <- lrTest(zlm, CoefficientHypothesis('conditionStim'))

## This would test if 2*cngeneson=conditionStim
#  This is sheer nonsense biologically and statistically, but gives an example of the flexibility.
## lrt <- lrTest(zlm, Hypothesis('2*cngeneson-conditionStim'))

```
We'll fit a hurdle model, modeling the condition and (centered) `ngeneson` factor, thus adjusting for the cellular detection rate.
We could run a likelihood ratio test here, testing for differences when we drop the `condition` factor.
Note that any arbitrary contrast matrix can be tested here, and specified either using a matrix or syntactically. See `Hypothesis` for details.


```{r zlmSummary}
summaryCond <- summary(zlmCond, doLRT='conditionStim') #only test the condition coefficient.
##print the top 4 genes by contrast using the logFC
print(summaryCond, n=4)
## by discrete Z-score
print(summaryCond, n=4, by='D')
## by continuous Z-score
print(summaryCond, n=4, by='C')
```
But often of more general use is this delicious syntactic sugar to make a giant `data.table` containing coefficients, standard errors, etc, for the various model components.
Many Bothan spies died so that we could pretty-print this summary of the top differentially expressed genes.


Strip off the `$datatable` component to stop this pretty-printing (or call `print.default`.)
```{r}
summaryDt <- summaryCond$datatable
fcHurdle <- merge(summaryDt[contrast=='conditionStim' & component=='H',.(primerid, `Pr(>Chisq)`)], #hurdle P values
                      summaryDt[contrast=='conditionStim' & component=='logFC', .(primerid, coef, ci.hi, ci.lo)], by='primerid') #logFC coefficients

fcHurdle[,fdr:=p.adjust(`Pr(>Chisq)`)]
fcHurdleSig <- merge(fcHurdle[fdr<.05 & abs(coef)>FCTHRESHOLD], as.data.table(mcols(sca)), by='primerid')
```
We see that there are `nrow(fcHurdleSig)` genes significant at a FDR of 5\% and with a log-fold change larger than `r FCTHRESHOLD`.


### Visualization of most differentially expressed genes

```{r, dependson="data;zlm",fig.width=8,fig.height=8}
entrez_to_plot <- fcHurdleSig[,primerid]
symbols_to_plot <- fcHurdleSig[,symbolid]
flat_dat <- as(sca[entrez_to_plot,], 'data.table')
ggbase <- ggplot(flat_dat, aes(x=condition, y=thresh,color=condition)) + geom_jitter()+facet_wrap(~symbolid)+ggtitle("DE Genes in Activated MAIT Cells")
ggbase+geom_violin()

flat_dat[,lmPred:=lm(thresh~cngeneson + condition)$fitted, key=symbolid]

ggbase +aes(x=cngeneson) + geom_line(aes(y=lmPred), lty=1)

## Stat ell example?

```

## Heatmap of MAITs based on most differentially expressed genes

Top 100 DE genes between stimulated and non-stimulated MAIT cells. 

```{r, dependson="data;zlm",fig.width=15,fig.height=10}
mat_to_plot <- assay(sca[entrez_to_plot,])
rownames(mat_to_plot) <- symbols_to_plot
aheatmap(mat_to_plot,annCol=colData(sca)[,"condition"],main="Top 100 DE genes",col=rev(colorRampPalette(colors = brewer.pal(name="PiYG",n=10))(20)))

```
Some of the activated MAITs have transcriptional profiles more similar to unactivated MAITS.

# Gene Set Enrichment Analysis
We use a competitive gene set enrichment test, in which a contrast (hurdle model coefficient) from various gene sets of interest is compared to the background, accounting for the intergene correlation of the module coefficient.

To estimate the intergene correlation of the contrast, we use bootstrapping.
Cells (columns in `sca`) are sampled with replacement a number of times and we refit the model.
At some point, we may implement a GEE-like method to estimate the intergene correlation through asymptotic calculations.
But in the meantime, the bootstrapping can be a bit slow, although is pleasingly parallelizable.
To avoid wasting too many CPU cycles, the result of such a bootstrap has been pre-calculated.
```{r boots, eval=FALSE}
#bootstrap
boots <- bootVcov1(zlmCond, 50)
saveRDS(boots, '../inst/extdata/bootstraps.rds')
```


```{r setupBTM, dependson="data;zlm;boots",results='hide'}
module <- "BTM"
min_gene_in_module <- 5
packageExt <- system.file("inst/extdata/", package='MAST')

boots <- readRDS(file.path(packageExt, 'bootstraps.rds'))
module_file <- list.files(packageExt, pattern = module, full.names = TRUE)
gene_set <- getGmt(module_file)
gene_ids <- geneIds(gene_set)
gene_ids <- gene_ids[!names(gene_ids)%like%"TBA"&!names(gene_ids)%like%"B cell"]
sets_indices <- ids2indices(gene_ids, mcols(sca)$symbolid)
# Only keep modules with at least min_gene_in_module
sets_indices <- sets_indices[sapply(sets_indices, length) >= min_gene_in_module]

```
We will use the Blood Transcriptional Modules of [Li, et al](www.nature.com/ni/journal/v15/n2/full/ni.2789.html) and select named modules not relating to B-cell functionality.


```{r gsea}
gsea <- gseaAfterBoot(zlmCond, boots, sets_indices, CoefficientHypothesis("conditionStim"))
t_stat_comb <- summary(gsea)

##Filter by effect size: discrete odds ratio of 1
t_stat_comb=t_stat_comb[set%in%names(which(abs(gsea[,"disc","stat","test"]-gsea[,"disc","stat","null"])>log(2.5) ))|set%in%names(which(abs(gsea[,"cont","stat","test"]-gsea[,"cont","stat","null"])>log2(1.5)))]
noyet <- FALSE
```



<!-- ### Visualization of most enriched modules -->

```{r, eval=noyet}
for (i in c(1:10,12,13)) {
    genes_to_plot <- unlist(gene_ids[names(gene_ids) == as.character(t_stat_comb$set[i])])
    gp <- ggplot(dt_long[gene_id %in% genes_to_plot], aes(x = condition, y = value, 
        color = condition)) + geom_violin() + geom_jitter() + facet_wrap(~gene_id,scale="free") + 
        labs(title = paste0(t_stat_comb$set[i], ", Z=", round(t_stat_comb$Z[i], 
            2), ", P=", round(t_stat_comb$P[i], 2)))
    print(gp)
}
```

<!-- ### Visualization of module "scores" for stimulated and unstimulated cells -->

```{r scores_fit, eval=noyet, fig.width=10,fig.height=10}
options("mc.cores" = LARGE_MEMORY_CORES)

score_4_hook <- function(x) {
  if (all(x@fitted)) {
    class(x@fitC) <- c("glm","lm")
    class(x@fitD) <- c("bayesglm","glm","lm")
    wh <- !colnames(x@modelMatrix) %like% "cngeneson"
    wh2 <- !names(coef(x@fitC)) %like% "cngeneson"
    fc <-
      x@modelMatrix[,!wh,drop = FALSE] %*% coef(x@fitC)[!wh2,drop = FALSE] #continuous CDR effect
    fd <-
      arm::invlogit(x@modelMatrix[,c("(Intercept)","cngeneson"),drop = FALSE] %*%
                      coef(x@fitD)[c("(Intercept)","cngeneson"),drop = FALSE]) #discrete CDR effect
    R <-
      matrix((x@response - fc * fd),nrow = 1) #residuals corrected for ngeneson in the continuous part
    colnames(R) <- names(residuals(x@fitD))
    R[x@response == 0] <- 0 - fd
    R
  }
}

zlm.scores <-
  zlm.SingleCellAssay(
    ~condition + cngeneson, sca, method = "bayesglm",
    ebayes = TRUE, ebayesControl = list(method = "MLE", model = "H1"),hook =
      score_4_hook
  )
```

```{r scores, eval=noyet,fig.width=10,fig.height=10}
scores <- do.call(rbind,zlm.scores@hookOut)
rownames(scores) <- names(zlm.scores@hookOut)

genes_to_plot <- sapply(1:nrow(t_stat_comb),function(i) {
unlist(gene_ids[names(gene_ids) == as.character(t_stat_comb$set[i])])
})
names(genes_to_plot) <- t_stat_comb$set

##Include the DE MAIT signature
mait_signature_genes_up = res_gene_hurdle[abs(logFC) > FCTHRESHOLD &
adj < 0.01][order(-abs(logFC),adj)][1:50,][logFC > 0,symbolid]
mait_signature_genes_down = res_gene_hurdle[abs(logFC) > FCTHRESHOLD &
adj < 0.01][order(-abs(logFC),adj)][1:50,][logFC < 0,symbolid]

genes_to_plot$"MAIT Activation [Up]" <- mait_signature_genes_up
genes_to_plot$"MAIT Activation [Down]" <- mait_signature_genes_down

genes_to_plot <- ldply(lapply(genes_to_plot,function(x)
data.frame(x)))
colnames(genes_to_plot) <- c("set","gene")
scores <- (melt(scores))

colnames(scores) <- c("gene","cell","score")

scores <- (merge(genes_to_plot,scores,by = "gene",all.y = TRUE))
condition <- cData(sca)[,"condition",drop = FALSE]
condition$cell <- rownames(condition)
scores <- (merge(scores,condition,by = "cell",all.x = TRUE))
scores <- na.omit(scores)
scores <- data.table(scores)
scores = scores[,set := factor(set)]
#t_stat_comb = t_stat_comb[,adj := p.adjust(P)]
scores$set <-
sapply(as.character(scores$set),function(x)
Kmisc::wrap(x,width = 25))
sets <-
sapply(t_stat_comb[order(-abs(t_stat_comb$Z),t_stat_comb$adj),set][c(1:9)],function(x)
Kmisc::wrap(x,25))
#sets <- gsub("\n$","",gsub(".\\(M.+$","",sets[!sets %like% "TBA"]))
gsea_scores <-
ggplot(scores[set %in% sets,list(score =
mean(score)),list(cell,set,condition)][,set := factor(set,levels = sets)]) +  geom_violin(show_guide =
FALSE) + geom_jitter(show_guide = FALSE) + aes(x = condition,y = score,col =
condition) + facet_wrap( ~set) + theme_linedraw() + theme(
plot.background = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line =
element_line(colour = "black"),legend.position = "bottom"
) + scale_color_manual("",values = c(brewer.pal(name = "PiYG",n = 3)[c(1)],"#5729EE"))

kable(dcast(scores[set %in% sets,list(score = mean(score)),list(cell,set,condition)][,set := factor(set,levels = sets)][,.(mad = sd(score)),.(condition,set)],set~condition),format = "latex")
```


### Heatmap and PCA of module scores

```{r, eval=noyet, fig.width=20,fig.height=13}
#heatmap of module scores
mat = dcast(unique(scores[,list(cell,set,score)]),cell~set,value.var="score",fun.aggregate=mean)
#colnames(mat) = gsub("\\n"," ",colnames(mat))
rownames(mat)=mat[,1]
mat=mat[,-1L]
COMPASS::pheatmap(mat,clustering_distance_rows="manhattan",clustering_distance_cols="manhattan")

library(stringr)
plot(prcomp(mat)$x[,1:2],col=factor(str_split_fixed(rownames(mat),"-",4)[,3]),pch=20)
legend("bottom",c("Stim","Non-stim"),col=c("black","red"),pch=20)

plot(prcomp(mat))

#sort(prcomp(mat)$rotation[,1])

```


<!-- ### Correlation of residuals across all cells using top 20 DE genes -->

```{r residuals,include=FALSE,eval=noyet,results='hide'} 
zlm.resid <- zlm.SingleCellAssay(~condition + cngeneson, sca, method = "bayesglm", 
    ebayes = TRUE, ebayesControl = list(method = "MLE", model = "H1"),hook=deviance_residuals_hook)

residuals<-do.call(rbind,zlm.resid@hookOut)
rownames(residuals)<-fData(sca)[,"symbolid"]
colnames(residuals)<-rownames(cData(sca))

genes_to_plot <- res_gene_hurdle[abs(logFC)>FCTHRESHOLD&adj<0.01][order(-abs(logFC),value)][1:20,symbolid]

#correlation amongst cells
C.s<-cor(residuals[genes_to_plot,cData(sca)[,"condition"]%in%"Stim"])
C.u<-cor(residuals[genes_to_plot,cData(sca)[,"condition"]%in%"Unstim"])
C<-cor(residuals[genes_to_plot,])

COMPASS::pheatmap(C,row_annotation=cData(sca)[,"condition",drop=FALSE],show_rownames=TRUE,show_colnames=FALSE,main="Correlation of residuals across all cells using top 20 DE genes",col=rev(colorRampPalette(colors = brewer.pal(name="PiYG",n=10))(20)),breaks = seq(-1,1,l=21))
```



<!-- ### PCA of residuals (model with ngeneson) -->

```{r pcaResid,eval=noyet, fig.width=10,include=FALSE}
library(grid)
PCbiplot <- function(PC, x="PC1", y="PC2", colors=c('black', 'black', 'red', 'red'),arrow_colors="red",point_colors="black",arrow_alpha=0.75,gene_subset=NULL) {
    # PC being a prcomp object
    data <- data.frame(obsnames=row.names(PC$x), PC$x)
    plot <- ggplot(data, aes_string(x=x, y=y)) +geom_point(color=point_colors)#+ geom_text(alpha=.8, size=3, aes(label=obsnames), color=point_colors)
    plot <- plot + geom_hline(aes(0), size=.2) + geom_vline(aes(0), size=.2, color=colors[2])
    datapc <- data.frame(varnames=rownames(PC$rotation), PC$rotation)
    mult <- min(
        (max(data[,y]) - min(data[,y])/(max(datapc[,y])-min(datapc[,y]))),
        (max(data[,x]) - min(data[,x])/(max(datapc[,x])-min(datapc[,x])))
        )
    datapc <- transform(datapc,
            v1 = .7 * mult * (get(x)),
            v2 = .7 * mult * (get(y))
            )
    plot <- plot + coord_equal() + geom_text(data=datapc[gene_subset,], aes(x=v1, y=v2, label=varnames), size = 4, vjust=1, color=arrow_colors,alpha=arrow_alpha)
    plot <- plot + geom_segment(data=datapc[gene_subset,], aes(x=0, y=0, xend=v1, yend=v2), arrow=arrow(length=unit(0.2,"cm")), alpha=arrow_alpha, color=arrow_colors)
    plot
}
residuals<-do.call(rbind,zlm.resid@hookOut)
rownames(residuals)<-fData(sca)[,"symbolid"]
colnames(residuals)<-rownames(cData(sca))
point_colors<-factor(cData(sca)[,"condition"],labels=c(Unstim=brewer.pal(name="PiYG",n=1)[1],Stim="#5729EE"))

genes_to_plot <- res_gene_hurdle[abs(logFC)>FCTHRESHOLD&adj<0.01][order(-abs(logFC),value)][1:50,symbolid]
pcaplot<-PCbiplot(prcomp(t(residuals[genes_to_plot,])),point_colors=point_colors,arrow_colors="blue",arrow_alpha=0.75,gene_subset=genes)+theme_bw()
```

<!-- ### Network estimation from residuals -->

```{r network,fig.width=10,eval=FALSE,echo=FALSE,include=FALSE,eval=noyet}
# library(Matrix)
# library(igraph)
# library(glasso)
# residuals<-do.call(rbind,zlm.resid@hookOut)
# rownames(residuals)<-fData(sca)[,"symbolid"]
# colnames(residuals)<-rownames(cData(sca))
# 
# getNetwork<-function(residuals=NULL,genes=NULL,rho=0.35,main=NULL,plot=TRUE){
#   g<-glasso(cor(t(residuals[genes,]),method="kendall"),rho=rho)
#   colnames(g$w)<-genes
#   rownames(g$w)<-genes
#   g<-graph.adjacency(g$w,mode="undirected",diag=FALSE,weighted=TRUE)
#   sort(igraph:::degree(g))
#   G<-subgraph(g,which(igraph:::degree(g)>0))
#   set.seed(10)
#   lay<-layout.fruchterman.reingold(G,area=vcount(G)^2.3,repulserad=vcount(G)^2)
#   if(plot){
#     plot(G,layout=lay,edge.width=3,vertex.size=18,vertex.label.cex=0.5,main=main)
#   }
#   G
# }
# 
# genes_to_plot <- res_gene_hurdle[,adj:=p.adjust(value,"fdr")][abs(logFC)>3&adj<0.01][order(-abs(logFC),adj)][,symbolid]
# G<-getNetwork(residuals[,cData(sca)[,"condition"]%in%c("Stim","Unstim")],genes_to_plot,0.35,main="Residuals network in MAIT")
# 
# 
# COMPASS::pheatmap(exprs(sca[,vertex.attributes(G)$name]),row_annotation=cData(sca)[,"condition",FALSE],main="Genes from residuals network in MAIT (with ngeneson)",col=rev(colorRampPalette(colors = brewer.pal(name="PiYG",n=10))(20)),breaks = seq(-1,1,l=21))
# COMPASS::pheatmap(cor(t(residuals[vertex.attributes(G)$name,])),main="gene-gene correlation from network estimation (with ngeneson)",col=rev(colorRampPalette(colors = brewer.pal(name="PiYG",n=10))(20)),breaks = seq(-1,1,l=21))
# gene_colors<-c("red","blue")[as.numeric(factor(sign(res_gene_hurdle[symbolid%in%vertex.attributes(G)$name,][order(symbolid),logFC])))]
# PCbiplot(prcomp((residuals[sort(vertex.attributes(G)$name),])),arrow_color=NA,point_colors=gene_colors)+ggtitle("PCA of residuals of genes from network estimate with ngeneson")
```

```{r,include=FALSE, eval=noyet}
library(class)
genes_to_plot <- res_gene_hurdle[abs(logFC)>FCTHRESHOLD&adj<0.01][order(-abs(logFC),adj)][1:100,symbolid]
qplot(x=GZMB,y=IFNG,data=(data.frame(cData(sca),exprs(subset(sca[,c("IFNG","GZMB")],condition%in%c("Stim","Unstim"))))),col=condition)+theme_linedraw()+geom_hline(y=12,lty=2)+geom_vline(x=10,lty=2)
#qplot(x=IFNG,y=SIN3A,data=(data.frame(cData(sca_stim),exprs((sca_stim[,c("SIN3A","RREB1","CD8A","IFNG","GZMB","PIM2","PIM1","NCOR1")])))),col=block)+theme_linedraw()

#IFNG < 12
#GZMB <10
blocked_cells<-data.table(cData(subset(sca,condition%in%c("Stim","Unstim"))),exprs(subset(sca[,c("IFNG","GZMB")],condition%in%c("Stim","Unstim"))))
blocked_cells[,block:=condition%in%"Stim"&GZMB<10&IFNG < 12]
sca_stim<-subset(sca,condition%in%"Stim")
cData(sca)<-merge(cData(sca),blocked_cells[,c("block","wellKey"),with=FALSE],by="wellKey",all=TRUE)
sca_noact<-subset(sca,condition%in%"Unstim"|block==TRUE)
#fit zlm
zlm_noact <- zlm.SingleCellAssay(~block + cngeneson, sca_noact, method = "bayesglm", ebayes = TRUE, ebayesControl = list(method = "MLE", model = "H1"),hook  =deviance_residuals_hook)
noact_logfc<-getLogFC(zlm_noact)
noact_logfc<-na.omit(noact_logfc[contrast=="blockTRUE"])
noact_logfc[order(-abs(logFC),2*(1-pnorm(abs(z)))),list(primerid,contrast,logFC,varLogFC,z,p=2*(1-pnorm(abs(z))),adj=p.adjust(2*(1-pnorm(abs(z))),"fdr"))][adj<0.05&abs(logFC)>FCTHRESHOLD]

lr_noact<-lrTest(object = zlm_noact,CoefficientHypothesis("blockTRUE"))
lr_noact<-dcast(melt(lr_noact[,"hurdle",]),primerid~metric)
lr_noact<-data.table(lr_noact)
lr_noact[,adj:=p.adjust(`Pr(>Chisq)`,"fdr")]
lr_noact[adj<0.05][order(adj)]

res_gene_noact<-merge(lr_noact,noact_logfc,by="primerid")
genes_to_plot_noact<-res_gene_noact[adj<0.15&abs(logFC)>log2(2)][order(-abs(logFC),adj)][,primerid]
colors<-colorRampPalette(brewer.pal(n=9,"PiYG"))(21)
colors[11]<-"#FFFFFF"
COMPASS:::pheatmap(exprs(sca_noact[,c(genes_to_plot_noact)]),scale="column",col=colors,breaks=seq(-4,4,l=21))
hmap_unstim_nonresponders<-grid.grab(wrap=TRUE)
```


```{r, eval=noyet}
nonresponders_biplot<-PCbiplot(prcomp(exprs(sca[,c(genes_to_plot_noact,genes_to_plot_block)])),x="PC1",y="PC2",point_colors = c("#E9A3C9","#5729EE")[cData(sca)$block+1],gene_subset=c(1:6,26,29:34))+theme_linedraw()+theme(aspect.ratio=1)+plotheme

pdf("../inst/extdata/output/Supplementary_Figure_14.pdf",width=24,height=7)
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow=1,ncol=3)))
vp<-viewport(layout.pos.row = 1,layout.pos.col = 1)
pushViewport(vp)
grid.draw(hmap_stim_nonresponders)
popViewport(n=2)
vp<-viewport(layout.pos.row = 1,layout.pos.col = 2)
pushViewport(vp)
grid.draw(hmap_unstim_nonresponders)
popViewport(n=2)
vp<-viewport(layout.pos.row = 1,layout.pos.col = 3)
pushViewport(vp)
print(nonresponders_biplot,vp=vp)
popViewport(n=2)
dev.off()

rowann<-cData(sca)[,"block",FALSE]
rowann$block<-factor(rowann$block)
rownames(rowann)<-rownames(exprs(sca[,c(genes_to_plot_noact,genes_to_plot_block)]))
#COMPASS:::pheatmap(exprs(sca[,unique(c(genes_to_plot_noact,genes_to_plot_block))]),row_annotation=rowann[,"block",FALSE])

library(org.Hs.eg.db)
symbols<-intersect(mappedkeys(org.Hs.egSYMBOL2EG),unique(c(genes_to_plot_noact,genes_to_plot_block)))
symbols<-melt(as.list(org.Hs.egSYMBOL2EG[symbols]))
setnames(symbols,c("egid","symbol"))
map<-melt(as.list(org.Hs.egMAP[as.character(symbols$egid)]))
setnames(map,c("chrmap","egid"))
symbols<-merge(map,symbols)
symbols<-data.table(symbols)
kable(symbols[chrmap%in%(symbols[,.N,chrmap][N>1]$chrmap)][order(chrmap)])
```

