##' Methods for analysing single cell assay data
##'
##' This packages provides data structures and functions for statistical analysis of single-cell assay data such as Fluidigm single cell gene expression assays.
##'
##' @name SingleCellAssay-package
##' @aliases SingleCellAssay-package
##' @docType package
##' @title "Tools for Single Cell Assay Analysis"
##' @keywords package
##' @rdname SingleCellAssay-package
##' @seealso \code{\link{SCASet}}
NULL
###=========GENERICS==================

##' Accessor for wellKey
##'
##' This returns the wellKey, which is a unique identifier generated by \code{idvars} in the \code{mapping}
##' @title getwellKey
##' @param sc An object with a \code{wellKey}
##' @return \code{integer} giving the unique id generated
##' @name getwellKey-method
##' 
##' @exportMethod getwellKey
##' @docType methods
##' @rdname getwellKey-methods
##' @keywords accessor
setGeneric('getwellKey', function(sc) standardGeneric('getwellKey'))


##' Accessor for cellData \code{data.frame}
##'
##' Returns the \code{cellData} \code{data.frame}.
##' @title cData
##' @param sc An object with \code{cellData}
##' @return \code{data.frame}
##'
##' 
##' @export
##' @docType methods
##' @rdname cData-methods
##' @keywords accessor
setGeneric('cData', function(sc) standardGeneric('cData'))

##' Accessor for cellData \code{AnnotatedDataFrame}
##'
##' Returns the \code{cellData}.
##' @title cData
##' @param sc An object with \code{cellData}
##' @return \code{AnnotatedDataFrame}
##'
##' 
##' @export
##' @docType methods
##' @rdname cellData-methods
##' @keywords accessor
setGeneric('cellData', function(sc) standardGeneric('cellData'))

##' Accessor for featureData \code{data.frame}
##'
##' Returns the \code{featureData} \code{data.frame}.
##' @title cData
##' @param sc An object with \code{featureData}
##' @return \code{data.frame}
##'
##' 
##' @export
##' @docType methods
##' @rdname fData-methods
##' @keywords accessor
setGeneric('fData', function(sc) standardGeneric('fData'))

##' Accessor for featureData \code{AnnotatedDataFrame}
##'
##' Returns the \code{featureData}.
##' @param sc An object with \code{featureData}
##' @return \code{AnnotatedDataFrame}
##'
##' 
##' @export
##' @docType methods
##' @rdname featureData-methods
##' @keywords accessor
setGeneric('featureData', function(sc) standardGeneric('featureData'))

##' Melt a rectangular array
##'
##' Return a 'molten' (flat) representation of a rectangular array
##'
##' @param data A rectangular array, with attributes attached to its rows and
##' columns
##' @return A \code{data.frame} typically, with the cartesian product of the
##' row and column attributes and the values from the rectangular array
##' 
##' 
##' @docType methods
##' @rdname melt-methods
##' @keywords transformation
##' @exportMethod melt
setGeneric("melt",function(data,...){
  standardGeneric("melt")
  })


##' Evaluate an expression (returning a \code{logical} vector in the context of
##' \code{x}
##'
##' Really just syntactic sugar.
##'
##' @param x A matrix or \code{data.frame} typically
##' @param thesubset An expression, which evaluated in either the current
##' environment, or the parent, yields a logical vector
##'
##' @return The same class as \code{x} typically, with entries in which thesubset was \code{TRUE}
##' 
##' @export
##' @docType methods
##' @rdname subset-methods
##' @keywords transformation
setGeneric('subset')


##' Return a deep copy of an object
##'
##' Because SingleCellAssay keeps the datastore in an environment, it's not sufficient to create a new object to make a copy on an object
##' @param sc object
##' @return copy of sc
##' @export
##' @docType methods
##' @rdname copy-methods
setGeneric('copy', function(object) standardGeneric('copy'))


##' @rdname getwellKey-methods
##' @aliases getwellKey,SingleCellAssay-method
setMethod('getwellKey', 'SingleCellAssay', function(sc) sc@wellKey)


nprimer <- function(sc){
  warning('called obsolete nprimer, use ncol')
  ncol(sc)
}

##' @export
##' ncol
##'
##' @title ncol
##' @rdname ncol-methods
##' @aliases ncol,SingleCellAssay-method
##' @author andrew
setMethod('ncol', 'SingleCellAssay', function(x) {
    return (nrow(fData(x)))
})

##' @export
##' nrow
##'
##' @title nrow
##' @rdname nrow-methods
##' @aliases nrow,SingleCellAssay-method
##' @keywords accessors
setMethod('nrow', 'SingleCellAssay', function(x) length(getwellKey(x)))

ncells <- function(sc){
  warning('called obsolete ncells, use nrow')
  nrow(sc)
}


##' @rdname cData-methods
##' @aliases cData,SingleCellAssay-method
##' @section Methods:
##' \describe{
##' \item{\code{sc = "SingleCellAssay"}}{}
##' }
setMethod('cData', 'SingleCellAssay', function(sc)  pData(sc@cellData))

##' @rdname cellData-methods
##' @aliases cellData,SingleCellAssay-method
setMethod('cellData', 'SingleCellAssay', function(sc) sc@cellData)

##' @rdname getMapNames-methods
##' @aliases getMapNames,SCA-method
setMethod('getMapNames', 'SCA', function(object) object@mapNames)


##' @rdname fData-methods
##' @aliases fData,SingleCellAssay-method
setMethod('fData', 'SingleCellAssay', function(sc) pData(sc@featureData))

##' @rdname featureData-methods
##' @aliases featureData,SingleCellAssay-method
setMethod('featureData', 'SingleCellAssay', function(sc)  sc@featureData)

##' @rdname melt-methods
##' @details \code{signature(data="SingleCellAssay")}: return a \code{data.frame}, which contains a melted version of \code{data}.
##' @aliases melt,SingleCellAssay-method
setMethod("melt","SingleCellAssay",function(data, ...) data@env$data )


##' @name [[
##' @details \code{signature(x="SingleCellAssay", i="ANY")}: \code{x[[i]]}, where \code{i} is a logical or integer vector, recycled as necessary to match \code{nrow(x)}
##' @aliases [[,SingleCellAssay,ANY-method
##' @keywords transform
##' @rdname doubleAngleBracket-methods
##' @export
try({ #this is needed to work around a bug in R that prevents redefining [[.
  ## see http://r.789695.n4.nabble.com/package-slot-of-generic-quot-quot-and-missing-env-target-td4634152.html
setMethod("[[", signature(x="SingleCellAssay", i="ANY"), function(x, i, ...){
### index by numeric index or boolean.
  selectedKeys <- getwellKey(x)[i]
  meltKeys <- melt(x)[,"__wellKey"] %in% selectedKeys
  env <- new.env()
  env$data <-melt(x)[meltKeys,]
  ##TODO: update phenodata
  newcdf <- cellData(x)[i,]
  
  cls<-class(x)[[1]]
  new(cls, env=env, mapping=x@mapping, id=x@id, wellKey=selectedKeys, featureData=x@featureData, cellData=newcdf)
}) }, silent=TRUE)


### Get cellular covariates in a SingleCellAssay object
covars <- function(sc, theCovars=NULL){
  warning('obsolete, use cData')
  selected <- c(unlist(strsplit(getlhs(sc@mapping), split="[+]")), theCovars)
  uniquerows <- unique(melt(sc)[, selected])
  sort_df(uniquerows)
}

##' Get or set a matrix of measurement values in a \code{SingleCellAssay}
##'
##' Return or set a matrix of the measurement: cells by primerids
##' @title exprs
##' @name exprs
##' @param object SingleCellAssay
##' @return numeric matrix
##' @docType methods
##' @rdname exprs-methods
##' @aliases exprs,SingleCellAssay-method
##' @importMethodsFrom Biobase exprs
##' @exportMethod exprs
setMethod("exprs",signature(object="SingleCellAssay"),function(object){
  nentries <- nrow(melt(object))        
  objrow <- nrow(object)
  objcol <- ifelse(nentries==0, 0, nentries/objrow) #handle case that the SingleCellAssay is empty
  matrix(melt(object)[,getMapping(object,"measurement")], nrow=objrow, ncol=objcol, 
         dimnames=list(object@wellKey, unique(melt(object)[, getMapping(object,"primerid")])))
})

##' @importMethodsFrom Biobase "pData<-"
##' @importMethodsFrom Biobase pData
##' @importMethodsFrom Biobase "exprs<-"
##' @rdname exprs-methods
##' @name exprs
##' @exportMethod "exprs<-"
##' @docType methods
##' @aliases exprs<-,SingleCellAssay,ANY-method
setReplaceMethod('exprs', c('SingleCellAssay', 'ANY'),
                 function(object, value){
                   measure <- getMapping(object,"measurement")
                   object@env$data[, measure] <- as.vector(value)
                   object
                 })

##' show methods
##' @exportMethod show
##' @aliases show,SingleCellAssay-method
##' @rdname show-methods
##'
setMethod("show","SingleCellAssay",function(object){
  cat(class(object), " id: ", object@id, "\n", nrow(object), " wells; ", ncol(object), " features\n")
  invisible(NULL)
})

##' @rdname subset-methods
##' @aliases subset,SingleCellAssay-method
##' @details \code{signature(x='SingleCellAssay', thesubset='ANY')}: Return a new SingleCellAssay consisting of cells in which thesubset is TRUE
setMethod('subset', 'SingleCellAssay', function(x, thesubset, ...){
  e <- substitute(thesubset)
  asBool <- try(eval(e, cData(x), parent.frame(n=2)), silent=TRUE)
  if(inherits(asBool, 'try-error')) stop(paste('Variable in subset not found:', strsplit(asBool, ':')[[1]][2]))
                  
  ## FIXME: makes the stack messy
  x[[asBool]]
})


##' Split into SCASet
##'
##' Splits a \code{SingleCellAssay} into a \code{SCASet} by a factor (or something coercible into a factor) or a character giving a column of the melted SingleCellAssay
##' @param x SingleCellAssay
##' @param f length-1 character or factor of length nrow(x)
##' @return SCASet
##' @docType methods
##' @rdname split-methods
##' @aliases split,SingleCellAssay,ANY-method
##' @name split
##' @exportMethod split
try({
setMethod('split', signature(x='SingleCellAssay', f='ANY', drop='ANY'), function(x, f, drop=FALSE, ...){
  ## Split a SingleCellAssay by criteria
  contentClass<-class(x)
  SCASet(melt(x), splitby=f, mapping=getMapping(x), contentClass=contentClass,...)
})
}, silent=TRUE)

## FIXME: gdata (not sure why it's imported) shadows the generic definition
setMethod('combine', signature(x='SingleCellAssay', y='SingleCellAssay'), function(x, y, ...) {
  scalist <- list(x, y, ...)
  scalist <- lapply(scalist, melt)
  dfbind <- do.call(rbind.fill, scalist)
  if(!all.equal(getMapping(x), getMapping(y))) stop('Can only combine alike SingleCellAssays')
  
  SingleCellAssay(dfbind, idvars=NULL, primerid=NULL, measurement=NULL, geneid=NULL, id=x@id, mapping=getMapping(x))
})




##' @exportMethod copy
##' @aliases copy,SingleCellAssay-method
##' @rdname copy-methods
setMethod('copy', 'SingleCellAssay',
          function(object){
            o2 <- object[[TRUE]]
            o2
          })

## OBSOLETE
## Build the left hand side (variables that corresponds to a unique cell) of a formula
## Still needed by covars...
getlhs <- function(mapping){
  paste(setdiff(mapping$idvars, mapping$primerid), collapse="+")
}

## Probably do not want to offer replacement methods for the data
## setGeneric("melt<-", function(x, value) standardGeneric("melt<-"))
## setReplaceMethod("melt", "SingleCellAssay",
##                  function(x, value){
##                    x@env$data <- value
## ### TODO: update cellData?
##                    x
##                  })
