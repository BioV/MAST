##' Methods for analysing single cell assay data
##'
##' This packages provides data structures and functions for statistical analysis of single-cell assay data such as Fluidigm single cell gene expression assays.
##'
##' @name SingleCellAssay-package
##' @aliases SingleCellAssay-package
##' @docType package
##' @title "Tools for Single Cell Assay Analysis"
##' @keywords package
##' @rdname SingleCellAssay-package
##' @seealso \code{\link{SCASet}}
NULL
###=========GENERICS==================

##' Accessor for wellKey
##'
##' This returns the wellKey, which is a unique identifier generated by \code{idvars} in the \code{mapping}
##' @title getwellKey
##' @param sc An object with a \code{wellKey}
##' @return \code{integer} giving the unique id generated
##' @name getwellKey-method
##' 
##' @exportMethod getwellKey
##' @docType methods
##' @rdname getwellKey-methods
##' @keywords accessor
setGeneric('getwellKey', function(sc) standardGeneric('getwellKey'))


##' Accessor for cellData \code{data.frame}
##'
##' Returns the \code{cellData} \code{data.frame}.
##' @title cData
##' @param sc An object with \code{cellData}
##' @return \code{data.frame}
##'
##' 
##' @export
##' @docType methods
##' @rdname cData-methods
##' @keywords accessor
setGeneric('cData', function(sc) standardGeneric('cData'))

##' Accessor for cellData \code{AnnotatedDataFrame}
##'
##' Returns the \code{cellData}.
##' @title cData
##' @param sc An object with \code{cellData}
##' @return \code{AnnotatedDataFrame}
##'
##' 
##' @export
##' @docType methods
##' @rdname cellData-methods
##' @keywords accessor
setGeneric('cellData', function(sc) standardGeneric('cellData'))

##' Accessor for featureData \code{data.frame}
##'
##' Returns the \code{featureData} \code{data.frame}.
##' @title fData
##' @param object An object with \code{featureData}
##' @return \code{data.frame} 
##' @docType methods
##' @rdname fData-methods
##' @keywords accessor
##' @name fData
##' @aliases fData,SingleCellAssay-method
##' @importMethodsFrom Biobase fData
#setGeneric('fData', function(sc) standardGeneric('fData'))
NULL

##' Accessor for featureData \code{AnnotatedDataFrame}
##'
##' Returns the \code{featureData}.
##' @param object An object with \code{featureData}
##' @return \code{AnnotatedDataFrame}
##' @docType methods
##' @rdname featureData-methods
##' @keywords accessor
##' @name featureData
##' @aliases featureData,SingleCellAssay-method
##' @importMethodsFrom Biobase featureData
#setGeneric('featureData', function(object) standardGeneric('featureData'))
NULL

##' Melt a rectangular array
##'
##' Return a 'molten' (flat) representation of a rectangular array
##'
##' @param data A rectangular array, with attributes attached to its rows and
##' columns
##' @param ... ignored
##' @return A \code{data.frame} typically, with the cartesian product of the
##' row and column attributes and the values from the rectangular array
##' 
##' 
##' @rdname melt
##' @title melt
##' @aliases melt
##' @keywords transformation
##' @importFrom reshape melt
##' @S3method melt SingleCellAssay
melt.SingleCellAssay<-function(data,...){
  m <- melt.data.frame(cbind(cData(data), exprs(data)), id.vars=names(cData(data)), variable_name='primerid')
  merge(m, fData(data), by='primerid')
}


mkunique<-function(x,G){
    cbind(x,primerid=make.unique(as.character(get(G,x))))
     }


check.vars <- function(cellvars, featurevars, phenovars, dataframe, nc, nr){
  if( any(cellvars %in% featurevars))
    stop("'cellvars', 'idvars' must be disjoint from 'featurevars', 'primerid', 'geneid'")
  cvars.in <- cellvars %in% names(dataframe)
  fvars.in <- featurevars %in% names(dataframe)
  if( !all(cvars.in)) stop(cellvars[!cvars.in][1], ' not found')
  if( !all(fvars.in)) stop(featurevars[!fvars.in][1], ' not found')
  
  nuniquef<-nrow(unique(dataframe[,featurevars, drop=FALSE]))
  nuniquec<-nrow(unique(dataframe[,cellvars, drop=FALSE]))  
  if(nuniquef != nc)
    stop("'featurevars' must be keyed by 'primerid'")
  if(nuniquec != nr)
    stop("'cellvars' must be keyed by 'idvars'")
}

## might have bad complexity, but could construct one at time, then glue cheaply
fixdf <- function(df, idvars, primerid, measurement, cmap, fmap){
  if(!inherits(df,"data.frame")){
    stop("Argument `dataframe` should be a data.frame.")
  }
  if(!all(idvars %in% colnames(df))){
    stop("Invalid idvars column name. Not in data.frame")
  }
  if(!all(primerid%in%colnames(df))){
    stop("Invalid primerid column name. Not in data.frame")
  }
  if(!all(measurement%in%colnames(df))){
    stop("Invalid measurement column name. Not in data.frame")
  }
  ## FIXME: should check if cmap and fmap are in df and throw intelligible error

  bothMap <- c(cmap, fmap)
  for(nm in names(bothMap)){
    if(nm %in% colnames(df) && bothMap[[nm]] != nm){
      names(df) <- make.unique(c(nm, colnames(df)))[-1]
    warning("renaming column ", nm)
    }
      if(!all(bothMap[[nm]] %in% names(df))){
        stop('could not find column named ', bothMap[[nm]], ' in dataframe')
      }
    rn <- nm
    names(rn) <- as.character(bothMap[[nm]])
    df <- rename(df, rn)
  }

  wk <- do.call(paste, df[,idvars, drop=FALSE])
  cellCounts <- table(wk)
  pid <- do.call(paste, df[,primerid, drop=FALSE])
  primerCounts <- table(pid)
  df[,'wellKey'] <- wk
  df[,'primerid'] <- pid
  incomplete <- !all(cellCounts == cellCounts[1])
  dupPrimers <- table(df$wellKey, df$primerid, exclude=NULL) #cross tab of primerid x wellKey
  duped.primers <- apply(dupPrimers>1, 2, which)
  
  if(length(duped.primers)>0){
    message("Primerid ", names(duped.primers)[1], " appears be duplicated.\n I will attempt to make it unique, but this may fail if the order of the primers is inconsistent in the dataframe.")
    df <- ddply(dataframe,'wellKey',mkunique,G='primerid')
  }
  
  if(incomplete){
    message("dataframe appears incomplete, attempting to complete it with NAs")
    skeleton <- expand.grid.df(unique(df[,"primerid", drop=FALSE]), unique(df[, "wellKey", drop=FALSE]))
    df <- merge(skeleton, df, all.x=TRUE, by=c('primerid', 'wellKey'))
  }

  ord <- do.call(order, df[, c("primerid", "wellKey")])
  df <- df[ord,]
  list(df=df, rn=unique(df$wellKey), cn=unique(df$primerid))
}

##' @importFrom plyr ddply
##' @importFrom reshape expand.grid.df
## unnamed arguments get passed along to callNextMethod
## which eventually just sets the slots
setMethod('initialize', 'SingleCellAssay',
          function(.Object, dataframe, idvars, primerid, measurement, cellvars=NULL, featurevars=NULL, phenovars=NULL, ...){
            .Object <- callNextMethod()
            if(!missing(dataframe)){              #called using melted dataframe
              if(missing(idvars) || missing(primerid) || missing(measurement)){
                stop("Must supply all of 'idvars', 'primerid' and 'measurement' if 'dataframe' is passed")
              }
            ## fixdf: make primerid unique, generate idvar column, rename columns according to cmap and fmap, complete df
            ## .Object@fmap[['primerid']] <- primerid
            ## .Object@cmap[['wellKey']] <- idvars
            fixed <- fixdf(dataframe, idvars, primerid, measurement, .Object@cmap, .Object@fmap)
            dl <- array(fixed$df[,measurement],
                        dim=c(length(fixed$rn), length(fixed$cn), length(measurement)),
                        dimnames=list(wellKey=fixed$rn, primerid=fixed$cn, layer=measurement))
            .Object@.Data <- dl
            cellvars <- union(cellvars, c('wellKey', idvars, phenovars, names(.Object@cmap))) #fixme when we support phenovars
            featurevars <- union(c('primerid', primerid, featurevars), names(.Object@fmap))
            check.vars(cellvars, featurevars, phenovars, fixed$df, length(fixed$cn), length(fixed$rn))
            cell.adf  <- new("AnnotatedDataFrame")
            pData(cell.adf)<-unique(fixed$df[,cellvars, drop=FALSE]) #automatically sorted by idvars
            sampleNames(cell.adf) <- unique(fixed$df$wellKey)

    ##pheno.adf <- new('AnnotatedDataFrame')
    ##need a phenokey into the melted data frame for this to make sense
    f.adf <- new('AnnotatedDataFrame')
            pData(f.adf) <- unique(fixed$df[,featurevars, drop=FALSE])
            sampleNames(f.adf) <- unique(fixed$df$primerid)
                                         .Object@cellData<-cell.adf
    .Object@featureData <- f.adf
            }
            

            .Object
          })





#setGeneric("melt",function(data,...){
#standardGeneric("melt")
#  UseMethod(generic="melt",data)
#  },useAsDefault=reshape::melt)

##' Evaluate an expression (returning a \code{logical} vector in the context of
##' \code{x}
##'
##' Really just syntactic sugar.
##'
##' @param x A matrix or \code{data.frame} typically
##' @param thesubset An expression, which evaluated in either the current
##' environment, or the parent, yields a logical vector
##'
##' @return The same class as \code{x} typically, with entries in which thesubset was \code{TRUE}
##' 
##' @export
##' @docType methods
##' @rdname subset-methods
##' @keywords transformation
setGeneric('subset')


##' Return a deep copy of an object
##'
##' Because SingleCellAssay keeps the datastore in an environment, it's not sufficient to create a new object to make a copy on an object
##' @param sc object
##' @return copy of sc
##' @export
##' @docType methods
##' @rdname copy-methods
setGeneric('copy', function(object) standardGeneric('copy'))


##' @rdname getwellKey-methods
##' @aliases getwellKey,SingleCellAssay-method
setMethod('getwellKey', 'SingleCellAssay', function(sc) {d<-data.table(unique(as.matrix(melt(sc)[,eval(SingleCellAssay:::todt(sc@wellKey))])));setkeyv(d,"__wellKey");d})


nprimer <- function(sc){
  warning('called obsolete nprimer, use ncol')
  ncol(sc)
}


ncells <- function(sc){
  warning('called obsolete ncells, use nrow')
  nrow(sc)
}


##' @rdname cData-methods
##' @aliases cData,SingleCellAssay-method
##' @section Methods:
##' \describe{
##' \item{\code{sc = "SingleCellAssay"}}{}
##' }
setMethod('cData', 'SingleCellAssay', function(sc)  pData(sc@cellData))

##' @rdname cellData-methods
##' @aliases cellData,SingleCellAssay-method
setMethod('cellData', 'SingleCellAssay', function(sc) sc@cellData)

## @rdname getMapNames-methods
## @aliases getMapNames,SCA-method
#setMethod('getMapNames', 'SCA', function(object) object@mapNames)
NULL

##' @rdname fData-methods
##' @aliases fData,SingleCellAssay-method
##' @exportMethod fData
setMethod('fData', 'SingleCellAssay', function(object) pData(object@featureData))

##' @rdname featureData-methods
##' @aliases featureData,SingleCellAssay-method
##' @exportMethod featureData
setMethod('featureData', 'SingleCellAssay', function(object)  object@featureData)

##' @rdname melt
##' @details \code{signature(data="SingleCellAssay")}: return a \code{data.frame}, which contains a melted version of \code{data}.
##' @aliases melt,SingleCellAssay-method
##' @exportMethod melt
setMethod("melt","SingleCellAssay",melt.SingleCellAssay )


##' @name [[
##' @title subset methods
##' @details \code{signature(x="SingleCellAssay", i="ANY")}: \code{x[[i]]}, where \code{i} is a logical, integer, or character vector, recycled as necessary to match \code{nrow(x)}. Optional \code{x[[i,j]]} where j is a logical, integer or character vector selecting the features based on ``primerid'' which is unique, while ``geneid'' or gene name is not necessarily unique. 
##' @aliases [[,SingleCellAssay,ANY-method
##' @keywords transform
##' @rdname doubleAngleBracket-methods
##' @export
try({ #this is needed to work around a bug in R that prevents redefining [[.
  ## see http://r.789695.n4.nabble.com/package-slot-of-generic-quot-quot-and-missing-env-target-td4634152.html
setMethod("[[", signature(x="SingleCellAssay", i="ANY"), function(x, i,j, drop=FALSE, ...){
### index by numeric index or boolean.
  wk<-getwellKey(x)
  if(missing(i)){
	i<-1:nrow(x)
  }
  if(inherits(i,"integer")|inherits(i,"logical")|inherits(i,"numeric")){
    if(inherits(i,"logical")){
      i<-which(i)
    }
    if(any(i>nrow(wk))){
      stop("well index out of bounds")
    }
    selectedKeys <- wk[i]
    #selected<-melt(x)[i]
  }else if(!all(i%in%wk)){
    stop("wellKeys not found in SingleCellAssay",i[!i%in%wk]);
  }
  m<-melt(x)
  setkeyv(m,"__wellKey")
  setkeyv(selectedKeys,"__wellKey")
  selectedFeatures<-m[selectedKeys]
  #meltKeys <- melt(x)[,"__wellKey",] %in% selectedKeys
  #selectedFeatures<-rep(TRUE,length(meltKeys));
  if(!missing(j)){
    if(inherits(j,"integer")|inherits(j,"numeric")|inherits(j,"logical")){
      if(is.logical(j)){
        j<-which(j)
      }
      setkeyv(m,getMapping(x,"primerid"))
      pk<-unique(m[,key(m),with=FALSE])
      #pk<-unique(melt(x)[,getMapping(x,"primerid")])
      if(any(j>nrow(pk))){
        stop("feature index out of bounds")
      }else{
        pk<-pk[j]
        setkeyv(selectedFeatures,getMapping(x,"primerid"))
        selectedFeatures<-selectedFeatures[pk]
        #selectedFeatures<-melt(x)[,getMapping(x,"primerid")]%in%pk
      }
    }else if(inherits(j,"character")){
      setkeyv(m,getMapping(x,"primerid"))
      pk<-unique(m[,key(m),with=FALSE])
      J<-which(pk$primerid%in%j)
      #pk<-unique(melt(x)[,getMapping(x,"primerid")])
      if(!(all(j%in%as.matrix(pk)))){
        stop("feature names \n",paste(j[!j%in%as.matrix(pk)],collapse=" "), "\n not found!");
      }
      pk<-pk[primerid%in%j] #note this assumes the primer key is one column and a character.. this has always been the case I'm just noting it here.
      setkeyv(selectedFeatures,getMapping(x,"primerid"))
      selectedFeatures<-selectedFeatures[pk]
      j<-J
    }
    if(!missing(j)){
      newfdf <- featureData(x)[j,]
    }
  }
  #meltKeys<-meltKeys&selectedFeatures
  env <- new.env()
  #env$data <-melt(x)[meltKeys,]
  setkeyv(selectedFeatures,getMapping(x,"idvars"))
  env$data<-selectedFeatures
  ##TODO: update phenodata
  newcdf <- cellData(x)[i,]
  if(!exists("newfdf")){
    newfdf<-x@featureData
  }
  cls<-class(x)[[1]]
  new(cls, env=env, mapping=x@mapping, id=x@id, wellKey="__wellKey", featureData=newfdf, cellData=newcdf)
}) }, silent=TRUE)


##' @rdname subset-methods
##' @aliases subset,SingleCellAssay-method
##' @details \code{signature(x='SingleCellAssay', thesubset='ANY')}: Return a new SingleCellAssay consisting of cells in which thesubset is TRUE
setMethod('subset', 'SingleCellAssay', function(x, thesubset, ...){
  e <- substitute(thesubset)
  asBool <- try(eval(e, cData(x), parent.frame(n=2)), silent=TRUE)
  if(inherits(asBool, 'try-error')) stop(paste('Variable in subset not found:', strsplit(asBool, ':')[[1]][2]))
  #this is a special case of "subset", not of the "[[" method, so..
  if(length(asBool)==1){
    if(asBool==TRUE){
      x 
    }else{
      x[[asBool]]
    }
  }else{
    x[[asBool]]
  }
})


##' Split into SCASet
##'
##' Splits a \code{SingleCellAssay} into a \code{SCASet} by a factor (or something coercible into a factor) or a character giving a column of the melted SingleCellAssay
##' @param x SingleCellAssay
##' @param f length-1 character or factor of length nrow(x)
##' @return SCASet
##' @docType methods
##' @rdname split-methods
##' @aliases split,SingleCellAssay,ANY-method
##' @name split
##' @exportMethod split
try({
setMethod('split', signature(x='SingleCellAssay'), function(x, f, drop=FALSE, ...){
  ## Split a SingleCellAssay by criteria
  contentClass<-class(x)
  m<-melt(x)
  mp<-getMapping(x)
  ###f must be a character naming a cData variable
  if(length(f)==1&class(f)%in%"character"){
    if(!f%in%colnames(cData(x))){
      stop(f," not in cData of x")
    }
    f<-factor(get(f,m))
  }else if(length(f)==nrow(cData(x))){
    setkeyv(m,getMapping(x,"idvars"))
    nc<-nrow(m)/nrow(cData(x))
    f<-factor(rep(f,each=nc))
  }else{
    stop("splitby must be a of length nrow(cData(x)) or a character naming a cData variable")
  }
  
  setkeyv(m,getMapping(x,"idvars"))
  SCASet(dataframe=m, splitby=f, mapping=mp, contentClass=contentClass,...)
})
}, silent=TRUE)


.SingleCellAssayCombine <- function(scalist){
  meltlist <- lapply(scalist, melt)
  dfbind <- do.call(rbind.fill, meltlist)
  stopifnot(length(scalist) >= 2)
  x <- scalist[[1]]
  y <- scalist[[2]]
  if(!all.equal(getMapping(x), getMapping(y))) stop('Can only combine alike SingleCellAssays')
  if(!all.equal(class(x),class(y))){
    stop("Cannot combine Assays of different classes")
  }
  contentClass<-class(x)[[1]]
  F <- try(getFunction(contentClass),silent=TRUE)
  if(inherits(F,"try-error"))
    message("Can't construct a class of type ",contentClass[[1]],". Constructor of this name doesn't exist")
  cl<-as.call(list(as.name(contentClass[[1]]),dataframe=dfbind,id=x@id,mapping=getMapping(x)))
  eval(cl)
  #SingleCellAssay(dfbind, idvars=NULL, primerid=NULL, measurement=NULL, geneid=NULL, id=x@id, mapping=getMapping(x),)
}


## FIXME: gdata (not sure why it's imported) shadows the generic definition
##'Combine two SingleCellAssay or derived classes
##'
##' combines two single cell assays provided they share a common mapping
##' TODO combining based on a common mapping may be too restrictive. This may change depending on needs.
##' @importMethodsFrom BiocGenerics combine
##' @exportMethod combine
##' @aliases combine,SingleCellAssay,SingleCellAssay-method
##' @docType methods
##' @rdname combine-methods
setMethod('combine', signature(x='SingleCellAssay', y='SingleCellAssay'), function(x, y, ...) {
  .SingleCellAssayCombine(list(x, y, ...))
})




##' @exportMethod copy
##' @aliases copy,SingleCellAssay-method
##' @rdname copy-methods
setMethod('copy', 'SingleCellAssay',
          function(object){
            o2 <- object[[1:nrow(object)]]
            o2
          })

