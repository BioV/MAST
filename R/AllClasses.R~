setOldClass("ncdf")

##' @import reshape
##' @import BiocGenerics
##' @importClassesFrom flowCore ncdfHandler NcdfOrMatrix
setClass("SCA",
         representation=representation(exprs="NcdfOrMatrix",
           "VIRTUAL"),
         prototype=list(exprs=matrix(numeric(0),
                          nrow=0,
                          ncol=0)
           ))



### SingleCellAssay class
SingleCellAssayValidity <- function(object){
  if(!inherits(get("data",envir=object@env),"data.frame")){
    message("Argument `dataframe` should be a data.frame.")
    return(FALSE)
  }
  if(!any(object@mapping$idvars %in% colnames(object@env$data))){
    warning("Invalid idvars column name. Not in data.frame")
    return(FALSE)
  }
  if(! ( object@mapping$geneid%in%colnames(object@env$data))){
    warning("Invalid geneid column name. Not in data.frame")
    return(FALSE)
  }
  if(!(object@mapping$primerid%in%colnames(object@env$data))){
    warning("Invalid primerid column name. Not in data.frame")
    return(FALSE)
  }
  if(!(object@mapping$measurement%in%colnames(object@env$data))){
    warning("Invalid measurement column name. Not in data.frame")
    return(FALSE)
  }
  return(TRUE)
}


Mandatory_Fields <- c('primerid', 'geneid', 'measurement', 'idvars')
SingleCellAssayNames <- c(Mandatory_Fields, 'cellvars', 'featurevars', 'phenovars')


#Mapping Class Related Functions and Methods and the Class Definition
.isValidNamedList<-function(mylist){
  if(length(mylist)==0){
    warning("namedlist cannot be empty")
    return(FALSE)
  }
  if(is.null(names(mylist))){
    warning("namedlist must contain names")
    return(FALSE)
  }
  if(any(gsub(" ","",names(mylist))%in%"")){
    warning("namedlist names cannot be empty")
    return(FALSE)
  }
  if(!all(do.call(c,lapply(mylist,class))%in%"character")){
    warning("namedlist must be a named list of character vectors")
    return(FALSE)
  }
  return(TRUE)
}

setClass("Mapping",representation(mapping="list"),prototype=list(mapping=list("_empty_mapping_"=NULL)),validity=function(object){
  return(.isValidNamedList(object@mapping))
})
setGeneric("getMapNames",function(object){standardGeneric("getMapNames")})
setMethod("getMapNames","Mapping",function(object){
  return(names(object@mapping))
})
setGeneric("getMapping",function(object,mapnames){standardGeneric("getMapping")})
setMethod("getMapping",c("Mapping","missing"),function(object){
  return(object@mapping)
})
setMethod("getMapping",c("Mapping","character"),function(object,mapnames){
  missing<-!mapnames%in%getMapNames(object)
  if(any(missing)){
    stop(manpnames[missing]," is not available in this Mapping")
  }
  return(object@mapping[mapnames])
})

setGeneric("isEmpty",function(object){standardGeneric("isEmpty")})
setMethod("isEmpty","Mapping",function(object){
  if(length(getMapNames(object))==0){
    return(TRUE)
  }
  if(getMapNames(object)%in%"_empty_mapping_"&length(getMapNames(object))==1){
    return(TRUE)
  }else{
    return(FALSE)
  }
 })

setGeneric("addMapping",function(object,namedlist){standardGeneric("addMapping")})
setMethod("addMapping",c("Mapping","list"),function(object,namedlist){
  if(!.isValidNamedList(namedlist)){
    stop("namedlist is not a valid named list for a Mapping")
  }
  if(isEmpty(mp)){
    mp@mapping<-namedlist
    return(mp)
  }else{
    mp@mapping<-c(mp@mapping,namedlist)
    return(mp)
  }
})

setGeneric("removeMapping",function(object,namedlist){standardGeneric("removeMapping")})
setMethod("removeMapping",c("Mapping","character"),function(object,namedlist){
  idx<-!getMapNames(object)%in%namedlist
  object@mapping<-object@mapping[idx]
  if(length(object@mapping)==0){
    object@mapping<-list("_empty_mapping_"=NULL)
  }
  return(object)
})

setMethod("show","Mapping",function(object){
  if(isEmpty(object)){
    cat("An Empty Mapping\n")
  }else{
    cat("Mapping of size ",length(object),"\n")
    cat("With maps: ",getMapNames(object),"\n")
  }
})

##Not to be called by the user
##' SingleCellAssay represents an arbitrary single cell assay
##' It is meant to be flexible and can (and will) be subclassed to represent specific assay
##' types like Fluidigm and others.
##' }
##' \section{Slots}{
##' \describe{
##'   \item{featureData}{an \code{AnnotatedDataFrame} that describes feature-level metadata (i.e. genes)}
##'   \item{phenoData}{an \code{AnnotatedDataFrame} that describes the phenotype-level metadata (i.e. subject or experimental unit)}
##'   \item{cellData}{an \code{AnnotatedDataFrame} that describes the cell-level metadata (i.e. per individual cell)}
##'   \item{mapNames}{a \code{character} vector that describes some mandatory fields used by the class to map data from the raw file to the object. These are defined in the package, class definintion and subclasses.}
##'   \item{mapping}{a named \code{character} vector that maps \code{mapNames} to column names in the raw data file or data frame. This provides some flexibility for changing file formats and future assay types.}
##'   \item{description}{a \code{data.frame}}
##'   \item{wellKey}{A unique key that identifies the well, which USUALLY contains a single cell being measured.}
##'   \item{id}{a vector of type \code{character} that identifies the set of columns acting as a primary key to uniquely identify a single-cell or single-well across all wells / cells / assays / subjects / conditions in the data set.}
##'   \item{env}{an environment that will hold the data}
##' }
##' @name SingleCellAssay-class
##' @docType class 
##' @aliases SingleCellAssay-class
##' @rdname SingleCellAssay-class
##' @exportClass SingleCellAssay
setClass("SingleCellAssay",
         representation=representation(featureData="AnnotatedDataFrame",
           phenoData="AnnotatedDataFrame",
           cellData="AnnotatedDataFrame",
           mapNames='character',
           mapping="Mapping",
           description='data.frame',
           cellKey='numeric',
           id="ANY",                    #experiment descriptor
           env="environment"),		   
         prototype=list(exprs=matrix(numeric(0),
                          nrow=0,
                          ncol=0),
           phenoData=new("AnnotatedDataFrame"),
           featureData=new("AnnotatedDataFrame"),
           cellData=new("AnnotatedDataFrame"),
           mapNames=SingleCellAssayNames,
           mapping=vector("list",5),
           description=data.frame(),
           cellKey=numeric(0),
           id=numeric(0),
           env=new.env()),validity=SingleCellAssayValidity)


## Same as SingleCellAssay, but with additional mapNames
FluidigmMapNames <- c(SingleCellAssayNames, 'ncells')
setClass('FluidigmAssay', contains='SingleCellAssay', prototype=prototype(mapNames=FluidigmMapNames))


setClass("SCASet",
         representation=list(set="list"),validity=function(object){
           if(all(names(object@set)!=unlist(lapply(object@set,function(x) x@id),use.names=FALSE))){
             warning("Names of the SCASet don't match the SingleCellAssay id's. Plese use the SingleCellAssay() constructor.")
             return(FALSE)
           }
           return(TRUE)
         })


##' SingleCellAssay: A constructor for an object of type SingleCellAssay.
##'
##' This is the constructor for the class. This class intends to ease the analysis of single cell assays, in which multiple, exchangible, cells from an experimental unit (patient, or organism) are assayed along several (or many) dimensions, such as genes. A few examples of this might be Fluidigm gene expression chips, or single cell sequencing experiments.  The chief functionality is to make it easy to keep cellular-level metadata linked to the measurements through \code{cellData} and \code{phenoData}.  There are also subsetting and splitting measures to coerce between a SingleCellAssay, and a \link{SCASet}.
##' @param dataframe A 'flattened' data.frame containing columns giving cell and feature identifiers and  a measurement column
##' @param idvars character vector naming columns that uniquely identify a cell
##' @param primerid character vector of length 1 that names the column that identifies what feature (i.e. gene) was measured
##' @param measurement character vector of length 1 that names the column containing the measurement 
##' @param geneid character vector of length 1 that names a 'gene' column.  This could be placed into ...?
##' @param id optional numeric (not sure what this is supposed to do)
##' @param mapping named list.  Names are identifiers used by find special columns in the dataframe.  This shouldn't be modified directly by the user
##' @param cellvars Character vector naming columns containing additional cellular metadata
##' @param featurevars Character vector naming columns containing additional feature metadata
##' @param phenovars Character vector naming columns containing additional phenotype metadata
##' @param ... Additional keywords to be added to mapping
##' @export
##' @aliases SingleCellAssay
##' @name SingleCellAssay
##' @rdname SingleCellAssay
##' @docType methods
##' @return SingleCellAssay object
SingleCellAssay<-function(dataframe,idvars,primerid,measurement,geneid=NULL,id=NULL, mapping=NULL, cellvars=NULL, featurevars=NULL, phenovars=NULL, ...){
  ### Add pheno key
  ### throw error if idvars isn't disjoint from geneid, probeid

  env<-new.env()

  ## BEGIN: place into a validObject method!
  others <- list(cellvars, featurevars, phenovars)
  notnull  <- unlist(lapply(others, function(x) !is.null(x)))  
  if(is.null(mapping)){
    mapping <- list(idvars=idvars,primerid=primerid,geneid=geneid,measurement=measurement, ...)
    mapping <- c(mapping, others[notnull])
  } else{
    if(! all(Mandatory_Fields %in% names(mapping)) )
      stop(paste('Mapping must contain at least ', paste(Mandatory_Fields, sep=', '), collapse=''))
    #Not sure why this check is here.. doesn't really make sense any more.
    if(any(notnull))
      stop(sprintf("Specify only one of 'mapping' or %s", c('cellvars', 'featurevars', 'phenovars')[notnull][1]))
  }
  ## END: place into validObject method!
  
  mapping <- within(mapping, {
         cellvars <- unique(c(cellvars, idvars, phenovars))
         featurevars <- unique(c(featurevars, primerid, geneid))
         })
  with(mapping, {
    if(length(intersect(cellvars, featurevars))>0)
      stop("'cellvars', 'idvars' must be disjoint from 'featurevars', 'primerid', 'geneid'")

    if(length(intersect(phenovars, featurevars))>0)
      stop("'phenovars' must be disjoint from 'featurevars', 'primerid', 'geneid'")
  
   if(nrow(unique(dataframe[, featurevars, drop=FALSE])) != nrow((unique(dataframe[, primerid, drop=FALSE]))))
       stop("'featurevars' must be keyed by 'primerid'")
   if(nrow(unique(dataframe[, cellvars, drop=FALSE])) != nrow((unique(dataframe[, idvars, drop=FALSE]))))
       stop("'cellvars' must be keyed by 'idvars'")
       })
  
  ##check if idvars exists in dataframe
  ##check if probeid exists in dataframe
  ##check if geneid exists in dataframe
  ##check if measurement exists in dataframe
  
  cellCounts <- table(do.call(paste, dataframe[,mapping$idvars]))
  incomplete <- !all(cellCounts == cellCounts[1])
  
  if(incomplete){
    message("dataframe appears incomplete, attempting to complete it with NAs")
    skeleton <- expand.grid.df(unique(dataframe[,mapping$featurevars, drop=FALSE]), unique(dataframe[, mapping$cellvars, drop=FALSE]))
    dataframe <- merge(skeleton, dataframe, all.x=TRUE, by=c(mapping$featurevars, mapping$cellvars))
    cellCounts <- table(do.call(paste, dataframe[,mapping$idvars]))
  }
  
  ord <- do.call(order, dataframe[, c(mapping$primerid, mapping$idvars)])
  dataframe <- dataframe[ord,]
  assign("data",dataframe,envir=env)
  cellKey <- seq_along(cellCounts)
  env$data$`__cellKey` <- rep(cellKey, times=cellCounts[1])
  protoassay <- new("SingleCellAssay",env=env,mapping=mapping,id=id,cellKey=cellKey)
  
    cell.adf  <- new("AnnotatedDataFrame")
    pData(cell.adf)<-melt(protoassay)[1:nrow(protoassay), mapping$cellvars, drop=FALSE]
    sampleNames(cell.adf) <- getcellKey(protoassay)

    ##pheno.adf <- new('AnnotatedDataFrame')
    ##need a phenokey into the melted data frame for this to make sense
    f.adf <- new('AnnotatedDataFrame')
    pData(f.adf) <- unique(melt(protoassay)[,mapping$featurevars, drop=FALSE])
    sampleNames(f.adf) <- unique(melt(protoassay)[,mapping$primerid])
    protoassay@cellData<-cell.adf
    protoassay@featureData <- f.adf
    

  
  return(protoassay)
}

FluidigmAssay<-function(dataframe,idvars,primerid,measurement, ncells, geneid=NULL,id=NULL, mapping=NULL, cellvars=NULL, featurevars=NULL, phenovars=NULL, ...){
  ## Factor out code that builds the mapping
  this.frame <- as.list(environment())
  this.frame$cellvars <- c(ncells, cellvars)
  sc <- do.call(SingleCellAssay, this.frame)
  as(sc, 'FluidigmAssay')
}

##' Constructs a SCASet, which is a list of SingleCellAssays
##'
##' FIXME
##' @title SCASet constructor
##' @param dataframe flat data.frame ala SingleCellAssay
##' @param splitby either a character vector naming columns or a factor or a list of factors used to split dataframe into SingleCellAssays
##' @param idvars character vector naming columns that uniquely identify a cell
##' @param primerid character vector of length 1 that names the column that containing what feature was measured
##' @param measurement character vector of length 1 that names the column containing the measurement
##' @param ... passed up to SingleCellAssay
##' @return SCASet
##' @aliases SCASet
##' @rdname SCAset-methods
##' @export
SCASet<-function(dataframe,splitby,idvars,primerid,measurement,...){
  if(is.character(splitby) && all(splitby %in% names(dataframe))){
  spl<-split(dataframe,dataframe[, splitby])
} else if(is.factor(splitby) || is.list(splitby) || is.character(splitby)){
  spl <- split(dataframe, splitby)
} else{
  stop("Invalid 'splitby' specification")
}

  set<-vector("list",length(spl))
  names(set)<-names(spl)
  for(i in seq_along(set)){
    set[[i]]<-SingleCellAssay(dataframe=spl[[i]],idvars=idvars,primerid=primerid,id=names(spl)[[i]], measurement=measurement,...)
  }
  new("SCASet",set=set)
}




